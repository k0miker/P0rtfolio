---
import Button from "./Button.astro";
import contactBg from "../assets/images/contact.jpg";
import { performanceMonitor } from '../utils/performanceMonitor.js';
---

<section 
  class="flex flex-col items-center content-center min-h-[80vh] p-4" 
  id="contact-section"
  style={`background-image: url(${contactBg.src})`}
>
  <form
    name="contact"
    class="offscreen"
    data-netlify="true"
    data-netlify-honeypot="bot-field"
    method="POST"    
  >
    <input type="hidden" name="bot-field" />
    <h1 class="font-[mono] md:mb-8 text-2xl hover:tracking-[0.5vw] duration-500 hover:text-[tomato] text-gray-200"> 
      Get in touch<span class="animate-ping">_</span><span
        class="animate-ping font-sans text-2xl">!</span
      >
    </h1>
    <div class="input-group">
      <input
        required
        type="text"
        name="name"
        class="input"
        id="name"
      />
      <label class="user-label" for="name">First Name</label>
    </div>
    <div class="input-group">
      <input
        required
        type="email"
        name="email"
        class="input"
        id="mail"
      />
      <label class="user-label" for="mail">E-Mail</label>
    </div>
    <div class="input-group">
      <textarea
        required
        name="text"
        rows="5"
        autocomplete="off"
        class="textarea input"
        id="message"></textarea>
      <label class="user-label" for="message">Message</label>
    </div>
    <div class="mt-4 text-gray-200">
      <div class="toggle-switch">
        <input type="checkbox" required id="toggle" class="toggle-input checkbox" />
        <label for="toggle" class="toggle-label"></label>
      </div>
      I agree to the <a
        href="https://www.netlify.com/privacy/"
        target="_blank"
        class="underline text-blue-300 text-base toggle-switch-label">privacy policy.</a
      >
    </div>
    <Button class="button" disabled />
  </form>
</section>

<style>
  section {
    align-items: center;
    justify-content: center;
    min-height: 95vh;
    padding-bottom: 150px;
    background-size: cover;
    box-shadow: inset 0px -2vh 10vw 10px var(--shadow-strong);
    background-attachment: fixed;
    transition: animation-play-state 0.3s;
  }
  
  section.animate {
    animation: slidein2 45s infinite alternate;
  }

  section.static-background {
    background-attachment: scroll;
  }

  form {
    padding: 25px;
    max-width: 668px;
    width: 100%;
    background-color: var(--form-bg);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 15px;
    transition: background-color 0.3s ease;
    position: relative;
    z-index: 0;

    h1 {
      color: var(--form-text);
      transition: 1s;
    }
  }
  span:nth-child(2) {
    display: none;
  }
  h1:hover span:nth-child(1) {
    display: none;
  }
  h1:hover span:nth-child(2) {
    display: inline-block;
  }
  .input-group {
    position: relative;
    padding: 15px;
  }

  .input {
    border: solid 1.5px var(--input-border);
    border-radius: 0.5rem;
    background: var(--input-bg);
    padding: 0.3rem;
    padding-left: 1rem;
    font-size: 1rem;
    color: var(--input-text);
    transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    width: 80vw;
    flex-grow: 1;
    max-width: 400px;
  }
  .textarea {
    border: solid 1.5px var(--input-border);
    border-radius: 1rem;
    font-size: 1rem;
    color: var(--input-text);
    transition: border 150ms cubic-bezier(0.4, 0, 0.2, 1);
  }
  .user-label {
    position: absolute;
    left: 35px;
    top: 8px;
    font-family: mono;
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--label-text);
    pointer-events: none;
    transform: translateY(1rem);
    transition: 550ms cubic-bezier(0.4, 0, 0.2, 1);
  }
  label:hover {
    color: var(--accent);
  }

  .input:focus,
  .input:valid {
    outline: none;
    outline: 2px solid var(--input-focus);
  }
  .input:focus {
  }
  .input:focus ~ label,
  .input:valid ~ label {
    left: 15px;
    top: -26px;
    background-color: transparent;
    padding: 0 0.2em;
    color: var(--accent);
  }
  
  .toggle-switch {
  position: relative;
  display: inline-block;
  width: 40px;
  top:5px;
  height: 25px;
}

.toggle-switch .toggle-input {
  display: none;
}
.toggle-switch-label {
  padding-bottom: 15px;
  color: var(--form-text);
}
  
.toggle-switch .toggle-label {

  position: absolute;
  top: 0;
  left: 0;
  width: 40px;
  height: 24px;
  background-color: var(--toggle-off-bg);
  border-radius: 14px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.toggle-switch .toggle-label::before {
  content: "";
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  top: 2px;
  left: 2px;
  background-color: #fff;
  box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, 0.3);
  transition: transform 0.3s;
}

.toggle-switch .toggle-input:checked + .toggle-label {
  background-color: var(--toggle-on-bg);
}

.toggle-switch .toggle-input:checked + .toggle-label::before {
  transform: translateX(16px);
}
.highlight {
  animation: highlight 0.5s;
}
@keyframes highlight {
  0% {
    scale: 1;
  }
  50{
    scale: 1.1;
  }
  100% {
    background-color: #33333391;
  }
}

/* Stil für deaktivierte Animationen */
#contact-background.no-animation {
  animation: none !important;
  transition: none !important;
}

:global([data-performance="low"]) #contact-section {
  background-attachment: scroll !important;
  background-image: linear-gradient(to bottom, var(--bg-primary), var(--bg-secondary)) !important;
}
</style>
<script>
  import { performanceMonitor } from '../utils/performanceMonitor.js';
  
  const form = document.querySelector("form");
  const input = document.querySelector(".checkbox") as HTMLInputElement;
  const toggle = document.querySelector(".toggle-switch");
  const toggleLabel = document.querySelector(".toggle-label");

  form.addEventListener("submit", (event) => {
    if (!input.checked) {
      event.preventDefault();
      toggle.classList.add("highlight");
      toggleLabel.classList.add("highlight");
      setTimeout(() => {
        toggle.classList.remove("highlight");
        toggleLabel.classList.remove("highlight");
      }, 500);
    }
  });

  // Animation nur starten, wenn Sektion im Viewport ist
  document.addEventListener("DOMContentLoaded", () => {
    const contactSection = document.getElementById("contact-section");
    
    // Prüfen des Performance-Modus
    const currentMode = document.documentElement.getAttribute('data-performance') || 
                        localStorage.getItem('performance-mode') || 'high';
    
    // Performance-basierte Einstellungen sofort anwenden
    if (contactSection) {
      if (currentMode === 'low') {
        // Low-Performance-Modus: Keine Animation, aber Hintergrund anzeigen
        contactSection.classList.remove("animate");
        contactSection.classList.add("static-background");
        contactSection.style.backgroundAttachment = "scroll";
        
        // Gradient-Hintergrund nur als Fallback, bewahre das Bild
        contactSection.style.backgroundImage = `url(${contactSection.getAttribute('style').match(/url\(['"](.*?)['"]\)/)[1]})`;
      } else {
        // Normaler Modus mit Animation bei Sichtbarkeit
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && currentMode !== 'low') {
              entry.target.classList.add("animate");
            } else {
              entry.target.classList.remove("animate");
            }
          });
        }, { threshold: 0.1 });
        
        observer.observe(contactSection);
      }
    }
    
    // Performance-Monitor Änderungsabonnement
    if (performanceMonitor && contactSection) {
      performanceMonitor.onPerformanceModeChange((mode) => {
        if (mode === 'low') {
          // Bei niedrigen FPS: Animation deaktivieren aber Hintergrund behalten
          contactSection.classList.remove('animate');
          contactSection.classList.add("static-background");
          contactSection.style.backgroundAttachment = 'scroll';
          
          // Sicherstellen dass der ursprüngliche Hintergrund beibehalten wird
          const originalBackground = contactSection.getAttribute('data-original-background');
          if (originalBackground) {
            contactSection.style.backgroundImage = originalBackground;
          }
        } else {
          // Bei hohen FPS: Normale Darstellung wiederherstellen
          contactSection.classList.remove("static-background");
          contactSection.style.backgroundAttachment = 'fixed';
          
          // Original-Hintergrund wiederherstellen
          const originalBackground = contactSection.getAttribute('data-original-background');
          if (originalBackground) {
            contactSection.style.backgroundImage = originalBackground;
          }
          
          // Animation Klasse nur hinzufügen wenn sichtbar
          if (isElementInViewport(contactSection)) {
            contactSection.classList.add('animate');
          }
        }
      });
    }
    
    // Original-Hintergrund speichern
    if (contactSection && !contactSection.hasAttribute('data-original-background')) {
      const backgroundImageStyle = contactSection.getAttribute('style');
      if (backgroundImageStyle) {
        const match = backgroundImageStyle.match(/background-image:\s*([^;]+)/);
        if (match) {
          contactSection.setAttribute('data-original-background', match[1]);
        }
      }
    }
    
    // Hilfsfunktion zur Prüfung, ob Element im Viewport ist
    function isElementInViewport(el) {
      const rect = el.getBoundingClientRect();
      return (
        rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.bottom >= 0
      );
    }
  });
</script>