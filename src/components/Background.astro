---
const { id = "background-canvas", opacity = "0.0", color = "var(--accent)" } = Astro.props;
---

<div class="background-container">
  <canvas id={id}></canvas>
</div>

<style define:vars={{ opacity, color }}>
  .background-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -10; 
    overflow: hidden;
    pointer-events: auto; /* Ändere zu auto, damit Mausinteraktion funktioniert */
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: var(--opacity);
    z-index: -10;
  }
</style>

<script define:vars={{ canvasId: id }}>
  // Hier wird die ID direkt als Variable übergeben, um document.currentScript zu vermeiden
  document.addEventListener("DOMContentLoaded", function() {
    try {
      // Canvas-Element direkt mit der ID abrufen
      const canvas = document.getElementById(canvasId);
      
      if (!canvas) {
        console.error(`Canvas mit ID "${canvasId}" nicht gefunden!`);
        return;
      }
      
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        console.error("2D Context konnte nicht erstellt werden");
        return;
      }
      
      // Globale Mauskoordinaten - direkt ohne window-Objekt
      let mouseX = 0;
      let mouseY = 0;
      let mouseActive = false;
      
      // Canvas-Größe anpassen
      function resizeCanvas() {
        const container = canvas.parentElement;
        if (!container) return;
        
        // Größe des Containers für Canvas verwenden
        const width = container.offsetWidth;
        const height = container.offsetHeight;
        
        // Wenn Container keine vernünftigen Maße hat, Viewport-Größe verwenden
        canvas.width = width > 0 ? width : window.innerWidth;
        canvas.height = height > 0 ? height : window.innerHeight;
        
        // Partikel bei Resize neu initialisieren
        if (particles.length === 0) {
          initParticles();
        }
      }
      
      // Partikel-Konfiguration
      let particles = [];
      const particleCount = 50;
      const colors = ["var(--accent)", "var(--text-secondary)", "tomato"];
      
      // Partikel initialisieren
      function initParticles() {
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 5 + 0.1,
            color: colors[Math.floor(Math.random() * colors.length)],
            vx: Math.random() * 0.5 - .25,
            vy: Math.random() * 0.5 - .25,
            life: Math.random(),
            lifeSpeed: 0.001 + Math.random() * .03,
            baseRadius: Math.random() * 2 + 1,
            opacity: 0
          });
        }
        console.log(`${particles.length} Partikel erstellt`);
      }
      
      // Animation-Loop
      function animate() {
        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Partikel zeichnen und bewegen
        particles.forEach((particle, index) => {
          particle.life += particle.lifeSpeed;
          
          if (particle.life > 1) {
            particles[index] = {
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              radius: Math.random() * 8 + 0.5,
              color: colors[Math.floor(Math.random() * colors.length)],
              vx: Math.random() * 0.5 - .025,
              vy: Math.random() * 0.5 - .025,
              life: 0,
              lifeSpeed: 0.001 + Math.random() * 0.003,
              baseRadius: Math.random() * 2 + 1,
              opacity: 0
            };
            return;
          }
          
          particle.opacity = Math.sin(particle.life * Math.PI) * 0.9;
          const sizeMultiplier = Math.sin(particle.life * Math.PI);
          particle.radius = particle.baseRadius * (10 + sizeMultiplier);
          
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
          ctx.fillStyle = particle.color;
          ctx.globalAlpha = particle.opacity;
          ctx.fill();
          
          particle.x += particle.vx;
          particle.y += particle.vy;
          
          // Mausinteraktion verbessert
          if (mouseActive) {
            const canvasRect = canvas.getBoundingClientRect();
            const relMouseX = mouseX - canvasRect.left;
            const relMouseY = mouseY - canvasRect.top;
            
            const dx = relMouseX - particle.x;
            const dy = relMouseY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 150) {
              particle.x += dx * 0.03;
              particle.y += dy * 0.03;
              particle.life = Math.max(0, particle.life - 0.02);
              particle.opacity = Math.min(0.9, particle.opacity + 0.1);
            }
          }
          
          if (particle.x < 0 || particle.x > canvas.width) {
            particle.vx = -particle.vx;
          }
          if (particle.y < 0 || particle.y > canvas.height) {
            particle.vy = -particle.vy;
          }
        });
        
        drawConnections();
      }
      
      function drawConnections() {
        for (let i = 0; i < particles.length; i++) {
          if (particles[i].opacity < 0.2) continue;
          
          for (let j = i + 1; j < particles.length; j++) {
            if (particles[j].opacity < 0.2) continue;
            
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 100) {
              ctx.beginPath();
              ctx.strokeStyle = particles[i].color;
              ctx.globalAlpha = 0.2 * (1 - distance / 100) * 
                               (particles[i].opacity * particles[j].opacity);
              ctx.lineWidth = 0.5;
              ctx.moveTo(particles[i].x, particles[i].y);
              ctx.lineTo(particles[j].x, particles[j].y);
              ctx.stroke();
            }
          }
        }
      }
      
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        mouseActive = true;
        
        if (Math.random() < 0.01) {
          console.log(`Mausposition: ${mouseX}, ${mouseY}`);
          const canvasRect = canvas.getBoundingClientRect();
          console.log(`Canvas-Position: ${canvasRect.left}, ${canvasRect.top}, Größe: ${canvasRect.width}x${canvasRect.height}`);
        }
      });
      
      document.addEventListener('mouseleave', () => {
        mouseActive = false;
      });
      
      setTimeout(() => {
        if (canvas && ctx) {
          resizeCanvas();
          animate();
          console.log(`Animation für '${canvasId}' gestartet`);
        }
      }, 500);
      
      window.addEventListener('resize', resizeCanvas);
    } catch (error) {
      console.error("Fehler bei der Background-Initialisierung:", error);
    }
  });
</script>
